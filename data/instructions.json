[
  {
    "command": "ADC",
    "operands": "Rd, Rr",
    "operation": "Rd\u2190Rd + Rr + C",
    "description": "Add two registers with carry",
    "flags": "--HSVNZC",
    "cycles": "1",
    "opcode": "0001 11rd dddd rrrr",
    "example": "; Add R1:R0 to R3:R2\r\nadd r2,r0 ; Add low byte\r\nadc r3,r1 ; Add with carry high byte\r"
  },
  {
    "command": "ADD",
    "operands": "Rd,Rr",
    "operation": "Rd\u2190Rd + Rr",
    "description": "Add two registers",
    "flags": "--HSVNZC",
    "cycles": "1",
    "opcode": "0000 11rd dddd rrrr",
    "example": "add r1,r2 ; Add r2 to r1 (r1=r1+r2)\r\nadd r28, r28 ; Add r28 to itself (r28=r28+r28)"
  },
  {
    "command": "ADIW",
    "operands": "Rh:Rl, K",
    "operation": "Rh:Rl\u2190Rh:Rl + K",
    "description": "Add immediate to Word (0 \u2264 K \u2264 63)",
    "flags": "---SVNZC",
    "cycles": "2",
    "opcode": "1001 0110 KKdd KKKK",
    "example": "adiw r25:24,1 ; Add 1 to r25:r24\r\nadiw ZH:ZL,63 ; Add 63 to the Z pointer(r31:r30)\r"
  },
  {
    "command": "AND",
    "operands": "Rd,Rr",
    "operation": "Rd\u2190Rd \u2022 Rr",
    "description": "Logical AND two registers",
    "flags": "---SVNZ-,\n  \nV cleared",
    "cycles": "1",
    "opcode": "0010 00rd dddd rrrr",
    "example": "and r2,r3 ; Bitwise and r2 and r3, result in r2\r\nldi r16,1 ; Set bitmask 0000 0001 in r16\r\nand r2, r16 ; Isolate bit 0 in r2\r"
  },
  {
    "command": "ANDI",
    "operands": "Rd, K",
    "operation": "Rd\u2190Rd \u2022 K",
    "description": "Logical AND with immediate (16 \u2264 d \u2264 31)",
    "flags": "---SVNZ-,\n  \nV cleared",
    "cycles": "1",
    "opcode": "0111 KKKK dddd KKKK",
    "example": "andi r17,$0F ; Clear upper nibble of r17\r\nandi r18,$10 ; Isolate bit 4 in r18\r\nandi r19,$AA ; Clear odd bits of r19\r"
  },
  {
    "command": "ASR",
    "operands": "Rd",
    "operation": "C\u2190Rd(0), Rd(6\u20260) \u2190Rd(7\u20261), Rd(7) \u2190Rd(7)",
    "description": "Arithmetic shift right",
    "flags": "---SVNZC",
    "cycles": "1",
    "opcode": "1001 010d dddd 0101",
    "example": "ldi 16,$10 ; Load decimal 16 into r16\r\nasr r16; r16=r16 / 2\r\nldi r17,$FC ; Load -4 in r17\r\nasr r17; r17=r17/2\r"
  },
  {
    "command": "BCLR",
    "operands": "s",
    "operation": "SREG(s) \u21900",
    "description": "Clear bit in status register",
    "flags": "SREG(s)",
    "cycles": "1",
    "opcode": "1001 0100 1sss 1000",
    "example": "bclr 0; Clear carry flag\r\nbclr 7; Disable interrupts\r"
  },
  {
    "command": "BLD",
    "operands": "Rd,b",
    "operation": "Rd(b) \u2190T",
    "description": "Load bit in register from T",
    "flags": "-T------",
    "cycles": "1",
    "opcode": "1111 100d dddd 0bbb",
    "example": "; Copy bit\r\nbst r1,2 ; Store bit 2 of r1 in T flag\r\nbld r0,4 ; Load T flag into bit 4 of r0\r"
  },
  {
    "command": "BRBC",
    "operands": "s,k",
    "operation": "if(SREG(s) = 0) PC\u2190PC + k + 1",
    "description": "Branch if status register flag cleared",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 01kk kkkk ksss",
    "example": "cpi r20,5 ; Compare r20 to the value 5\r\nbrbc 1,noteq ; Branch if zero flag cleared\r\n...\r\nnoteq:nop ; Branch destination (do nothing)\r"
  },
  {
    "command": "BRBS",
    "operands": "s,k",
    "operation": "if(SREG(s) = 1) PC\u2190PC + k + 1",
    "description": "Branch if status register flag set",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 00kk kkkk ksss",
    "example": "bstr 0,3 ; Load T bit with bit 3 of r0\r\nbrbs 6, bitset ; Branch T bit was set\r\n...\r\nbitset: nop ; Branch destination (do nothing)\r"
  },
  {
    "command": "BRCC",
    "operands": "k",
    "operation": "if(C=0) then PC\u2190PC + k + 1",
    "description": "Branch if carry cleared, Same as brbc 0,k and brsh",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 01kk kkkk k000",
    "example": "add r22,r23 ; Add r23 to r22\r\nbrcc nocarry ; Branch if carry cleared\r\n ...\r\nnocarry: nop ; Branch destination (do nothing)\r"
  },
  {
    "command": "BRCS",
    "operands": "k",
    "operation": "if(C=1) then PC\u2190PC + k + 1",
    "description": "Branch if carry set, Same as brbs 0,k and brlo",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 00kk kkkk k000",
    "example": "cpi r26, $56 ; Compare r26 with $56\r\nbrcs carry ; Branch if carry set\r\n...\r\ncarry: nop ; Branch destination (do nothing)\r"
  },
  {
    "command": "BREAK",
    "operands": "",
    "operation": "",
    "description": "For on-chip debug only",
    "flags": "--------",
    "cycles": "1",
    "opcode": "1001 0101 1001 1000",
    "example": ""
  },
  {
    "command": "BREQ",
    "operands": "k",
    "operation": "if(Z=1) then PC\u2190PC + k + 1",
    "description": "Branch if equal, Same as brbs 1,k",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 00kk kkkk k001",
    "example": "cp r1, r0 ; Compare registers r1 and r0\r\nbreq equal ; Branch if registers equal\r\n...\r\nequal: nop ; Branch destination (do nothing)\r"
  },
  {
    "command": "BRGE",
    "operands": "k",
    "operation": "if(S=0) then PC\u2190PC + k + 1",
    "description": "Branch if greater or equal (signed), Same as brbc 4,k",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 01kk kkkk k100",
    "example": "cp r11,r12 ; Compare registers r11 and r12\r\nbrge greateq ; Branch if r11 \u2265 r12 (signed)\r\n...\r\ngreateq: nop ; Branch destination (do nothing)\r"
  },
  {
    "command": "BRHC",
    "operands": "k",
    "operation": "if(H=0) then PC\u2190PC + k + 1",
    "description": "Branch if half-carry flag cleared, Same as brbc 5,k",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 01kk kkkk k101",
    "example": "brhc hclear ; Branch if half carry flag cleared\r\n...\r\nhclear: nop ; Branch destination (do nothing)\r"
  },
  {
    "command": "BRHS",
    "operands": "k",
    "operation": "if(H=1) then PC\u2190PC + k + 1",
    "description": "Branch if half-carry flag set, Same as brbs 5,k",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 00kk kkkk k101",
    "example": "brhs hset ; Branch if half carry flag set\r\n...\r\nhset: nop ; Branch destination (do nothing)\r"
  },
  {
    "command": "BRID",
    "operands": "k",
    "operation": "if(I=0) then PC\u2190PC + k + 1",
    "description": "Branch if interrupt disabled, Same as brbc 7,k",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 01kk kkkk k111",
    "example": "brid intdis ; Branch if interrupt disabled\r\n...\r\nintdis:nop ; Branch destination (do nothing)\r"
  },
  {
    "command": "BRIE",
    "operands": "k",
    "operation": "if(I=1) then PC\u2190PC + k + 1",
    "description": "Branch if interrupts enabled, Same as brbs 7,k",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 00kk kkkk k111",
    "example": "brie inten ; Branch if interrupt enabled\r\n...\r\ninten:nop ; Branch destination (do nothing)\r"
  },
  {
    "command": "BRLO",
    "operands": "k",
    "operation": "if(C=1) then PC\u2190PC + k + 1",
    "description": "Branch if lower, unsigned, Same as brbs 0,k and brcs",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 00kk kkkk k000",
    "example": "eor r19,r19 ; Clear r19\r\nloop:incr19 ; Increase r19\r\n...\r\ncpi r19,$10 ; Compare r19 with $10\r\nbrlo loop ; Branch if r19 < $10 (unsigned)\r\nnop ; Exit from loop (do nothing)"
  },
  {
    "command": "BRLT",
    "operands": "k",
    "operation": "if(S=1) then PC\u2190PC + k + 1",
    "description": "Branch if less than (signed), Same as brbs 4,k",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 00kk kkkk k100",
    "example": "cpi r19,$8 ; compare r19 with $8\nbrlt label ; branch if r19 < $8\n           ; (signed)"
  },
  {
    "command": "BRMI",
    "operands": "k",
    "operation": "if(N=1) then PC\u2190PC + k + 1",
    "description": "Branch if minus, Same as brbs 2,k",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 00kk kkkk k010",
    "example": "subi r18, 4 ; subtract 4 from r18\nbrmi label ; branch if result\n           ; negative"
  },
  {
    "command": "BRNE",
    "operands": "k",
    "operation": "if(Z=0) then PC\u2190PC + k + 1",
    "description": "Branch if not equal, Same as brbc 1,k",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 01kk kkkk k001",
    "example": "eor r27,r27 ; Clear r27\r\nloop:inc r27 ; Increase r27\r\n...\r\ncpir27,5 ; Compare r27 to 5\r\nbrneloop ; Branch if r27\u21d45\r\nnop ; Loop exit (do nothing)"
  },
  {
    "command": "BRPL",
    "operands": "k",
    "operation": "if(N=0) then PC\u2190PC + k + 1",
    "description": "Branch if plus, Same as brbc 2,k",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 01kk kkkk k010",
    "example": "subi r26,$50 ; Subtract $50 from r26\r\nbrpl positive ; Branch if r26 positive\r\n...\r\npositive:nop ; Branch destination (do nothing)"
  },
  {
    "command": "BRSH",
    "operands": "k",
    "operation": "if(C=0) then PC\u2190PC + k + 1",
    "description": "Branch if same or higher, unsigned, Same as brbc 0,k and brcc",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 01kk kkkk k000",
    "example": "subi r19,4 ; Subtract 4 from r19\r\nbrsh highsm ; Branch if r19 >= 4 (unsigned)\r\n...\r\nhighsm:nop ; Branch destination (do nothing)"
  },
  {
    "command": "BRTC",
    "operands": "k",
    "operation": "if(T=0) then PC\u2190PC + k + 1",
    "description": "Branch if T flag cleared, Same as brbc 6,k",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 01kk kkkk k110",
    "example": "bst r3,5 ; Store bit 5 of r3 in T flag\r\nbrtc tclear ; Branch if this bit was cleared\r\n...\r\ntclear:nop ; Branch destination (do nothing)"
  },
  {
    "command": "BRTS",
    "operands": "k",
    "operation": "if(T=1) then PC\u2190PC + k + 1",
    "description": "Branch if T flag set, Same as brbs 6,k",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 00kk kkkk k110",
    "example": "bst r3,5 ; Store bit 5 of r3 in T flag\r\nbrts tset ; Branch if this bit was set\r\n...\r\ntset:nop ; Branch destination (do nothing)"
  },
  {
    "command": "BRVC",
    "operands": "k",
    "operation": "if(V=0) then PC\u2190PC + k + 1",
    "description": "Branch if overflow flag is cleared, Same as brbc 3,k",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 01kk kkkk k011",
    "example": "add r3,r4 ; Add r4 to r3\r\nbrvc noover ; Branch if no overflow\r\n...\r\nnoover:nop ; Branch destination (do nothing)"
  },
  {
    "command": "BRVS",
    "operands": "k",
    "operation": "if(V=1) then PC\u2190PC + k + 1",
    "description": "Branch if overflow flag is set, Same as brbs 3,k",
    "flags": "--------",
    "cycles": "1,2*",
    "opcode": "1111 00kk kkkk k011",
    "example": "add r3,r4 ; Add r4 to r3\r\nbrvs overfl ; Branch if overflow\r\n...\r\noverfl:nop ; Branch destination (do nothing)"
  },
  {
    "command": "BSET",
    "operands": "s",
    "operation": "SREG(s) \u21901",
    "description": "Set bit in status register",
    "flags": "SREG(s)",
    "cycles": "1",
    "opcode": "1001 0100 0sss 1000",
    "example": "bset 6 ; Set T flag\r\nbset 7 ; Enable interrupt"
  },
  {
    "command": "BST",
    "operands": "Rr,b",
    "operation": "T\u2190Rr(b)",
    "description": "Bit store from register to T",
    "flags": "-T------",
    "cycles": "1",
    "opcode": "1111 101d dddd 0bbb",
    "example": "; Copy bit\r\nbst r1,2 ; Store bit 2 of r1 in T flag\r\nbld r0,4 ; Load T into bit 4 of r0"
  },
  {
    "command": "CALL",
    "operands": "k",
    "operation": "PC\u2190k; Stack\u2190PC + 2; SP\u2190SP\u20132",
    "description": "Direct subroutine call. 0\u2264k\u226464K",
    "flags": "--------",
    "cycles": "4",
    "opcode": "1001 010k kkkk 111k kkkk kkkk kkkk kkkk",
    "example": "mov r16,r0 ; Copy r0 to r16\r\ncall check ; Call subroutine\r\nnop ; Continue (do nothing)\r\n...\r\ncheck: cpi r16, $42 ; Check if r16 has a special value\r\nbreq error ; Branch if equal\r\nret ; Return from subroutine\r\n...\r\nerror: rjmp error ; Infinite loop"
  },
  {
    "command": "CBI",
    "operands": "P, b",
    "operation": "IO[P](b) \u21900",
    "description": "Clear bit in I/O register, only for 0\u2264P\u226431",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 1000 PPPP Pbbb",
    "example": "cbi $12, 7 ; Clear bit 7 in Port D"
  },
  {
    "command": "CBR",
    "operands": "Rd, K",
    "operation": "Rd\u2190Rd\u2022K",
    "description": "Clear bit(s) in register, only for 16\u2264d\u226431",
    "flags": "---SVNZ-,\n  \nV cleared",
    "cycles": "1",
    "opcode": "As per ANDi with K Complemented",
    "example": "cbr r16, $F0 ; Clear upper nibble of r16\r\ncbr r18, 1 ; Clear bit 0 in r18"
  },
  {
    "command": "CLC",
    "operands": "",
    "operation": "C\u21900",
    "description": "Clear carry flag, Same as bclr 0",
    "flags": "-------C",
    "cycles": "1",
    "opcode": "1001 0100 1000 1000",
    "example": "add r0, r0 ; Add r0 to itself\r\nclc ; Clear carry flag"
  },
  {
    "command": "CLH",
    "operands": "",
    "operation": "H\u21900",
    "description": "Clear half-carry flag, Same as bclr 5",
    "flags": "--H-----",
    "cycles": "1",
    "opcode": "1001 0100 1101 1000",
    "example": "clh; Clear the Half Carry flag"
  },
  {
    "command": "CLI",
    "operands": "",
    "operation": "I\u21900",
    "description": "Clear global interrupt flag (disable interrupts), Same as bclr 7",
    "flags": "I-------",
    "cycles": "1",
    "opcode": "1001 0100 1111 1000",
    "example": "in temp, SREG ; Store SREG value (temp must be defined by user)\r\ncli ; Disable interrupts during timed sequence\r\nsbi EECR, EEMWE ; Start EEPROM write\r\nsbi EECR, EEWE\r\nout SREG, temp ; Restore SREG value (I-flag)"
  },
  {
    "command": "CLN",
    "operands": "",
    "operation": "N\u21900",
    "description": "Clear negative flag, Same as bclr 2",
    "flags": "-----N--",
    "cycles": "1",
    "opcode": "1001 0100 1010 1000",
    "example": "add r2,r3 ; Add r3 to r2\r\ncln ; Clear negative flag"
  },
  {
    "command": "CLR",
    "operands": "Rd",
    "operation": "Rd\u2190Rd \u2295 Rd",
    "description": "Clear register, Same as eor Rd, Rd",
    "flags": "---SVNZ-,\n  \nZ set; S,V,N cleared",
    "cycles": "1",
    "opcode": "0010 01Dd dddd DDDD (DDDDD=ddddd)",
    "example": "clr r18 ; clear r18\r\nloop: inc r18 ; increase r18\r\n...\r\ncpi r18, $50 ; Compare r18 to $50\r\nbrne loop"
  },
  {
    "command": "CLS",
    "operands": "",
    "operation": "S\u21900",
    "description": "Clear signed flag, Same as bclr 4",
    "flags": "---S----",
    "cycles": "1",
    "opcode": "1001 0100 1100 1000",
    "example": "add r2,r3 ; Add r3 to r2\r\ncls ; Clear signed flag"
  },
  {
    "command": "CLT",
    "operands": "",
    "operation": "T\u21900",
    "description": "Clear T flag, Same as bclr 6",
    "flags": "-T------",
    "cycles": "1",
    "opcode": "1001 0100 1110 1000",
    "example": "clt ; Clear T flag"
  },
  {
    "command": "CLV",
    "operands": "",
    "operation": "V\u21900",
    "description": "Clear overflow flag, Same as bclr 3",
    "flags": "----V---",
    "cycles": "1",
    "opcode": "1001 0100 1011 1000",
    "example": "add r2,r3 ; Add r3 to r2\r\nclv ; Clear overflow flag"
  },
  {
    "command": "CLZ",
    "operands": "",
    "operation": "Z\u21900",
    "description": "Clear zero flag, Same as bclr 1",
    "flags": "------Z-",
    "cycles": "1",
    "opcode": "1001 0100 1001 1000",
    "example": "add r2,r3 ; Add r3 to r2\r\nclz; Clear zero"
  },
  {
    "command": "COM",
    "operands": "Rd",
    "operation": "Rd\u2190Rd or Rd\u2190$FF \u2013 Rd",
    "description": "One\u2019s complement (inversion)",
    "flags": "---SVNZC,\n  \nV cleared,\u00a0 \nC set",
    "cycles": "1",
    "opcode": "1001 010d dddd 0000",
    "example": "com r4 ; Take one's complement of r4\r\nbreq zero ; Branch if zero\r\n...\r\nzero: nop ; Branch destination (do nothing)"
  },
  {
    "command": "CP",
    "operands": "Rd, Rr",
    "operation": "Rd \u2013 Rr",
    "description": "Compare",
    "flags": "--HSVNZC",
    "cycles": "1",
    "opcode": "0001 01rd dddd rrrr",
    "example": "cp r4,r19 ; Compare r4 with r19\r\nbrne noteq ; Branch if r4 \u21d4 r19\r\n...\r\nnoteq: nop ; Branch destination (do nothing)"
  },
  {
    "command": "CPC",
    "operands": "Rd,Rr",
    "operation": "Rd \u2013 Rr \u2013 C",
    "description": "Compare with Carry",
    "flags": "--HSVNZC",
    "cycles": "1",
    "opcode": "0000 01rd dddd rrrr",
    "example": "; Compare r3:r2 with r1:r0\r\ncp r2,r0 ; Compare low byte\r\ncpc r3,r1 ; Compare high byte\r\nbrne noteq ; Branch if not equal\r\n...\r\nnoteq:nop ; Branch destination (do nothing)"
  },
  {
    "command": "CPI",
    "operands": "Rd, K",
    "operation": "Rd \u2013 K",
    "description": "Compare with immediate, 16\u2264 d \u2264 31",
    "flags": "--HSVNZC",
    "cycles": "1",
    "opcode": "0011 KKKK dddd KKKK",
    "example": "cpi r19,3 ; Compare r19 with 3\r\nbrne error ; Branch if r19\u21d43\r\n...\r\nerror: nop ; Branch destination (do nothing)"
  },
  {
    "command": "CPSE",
    "operands": "Rd,Rr",
    "operation": "if(Rd=Rr) PC\u2190PC + 2 (or 3)",
    "description": "Compare, skip if equal.",
    "flags": "--------",
    "cycles": "1,2,\n3\u2020",
    "opcode": "0001 00rd dddd rrrr",
    "example": "inc r4 ; Increase r4\r\ncpse r4,r0 ; Compare r4 to r0\r\nneg r4 ; Only executed if r4\u21d4r0\r\nnop ; Continue (do nothing)"
  },
  {
    "command": "DEC",
    "operands": "Rd",
    "operation": "Rd\u2190Rd \u2013 1",
    "description": "Decrement register",
    "flags": "---SVNZ-",
    "cycles": "1",
    "opcode": "1001 010d dddd 1010",
    "example": "ldi r17, $10 ; Load constant in r17\r\nloop: add r1, r2 ; Add r2 to r1\r\ndec r17 ; Decrement r17\r\nbrne loop ; Branch if r17\u21d40\r\nnop; Continue (do nothing)"
  },
  {
    "command": "EOR",
    "operands": "Rd,Rr",
    "operation": "Rd\u2190Rd \u2295 Rr",
    "description": "Exclusive OR two registers",
    "flags": "---SVNZ-,\n  \nV cleared",
    "cycles": "1",
    "opcode": "0010 01rd dddd rrrr",
    "example": "eor r4,r4 ; Clear r4\r\neor r0,r22 ; Bitwise exclusive or between r0 and r22"
  },
  {
    "command": "FMUL",
    "operands": "Rd, Rr",
    "operation": "R1:R0 \u2190 Rd x Rr",
    "description": "Multiply unsigned 1.7 fractional number by another. 16 \u2264 d \u2264 23, 16 \u2264 r \u2264 23",
    "flags": "------ZC",
    "cycles": "2",
    "opcode": "0000 0011 0ddd 1rrr",
    "example": ";******************************************************************************\r\n;* DESCRIPTION\r\n;*Signed fractional multiply of two 16-bit numbers with 32-bit result.\r\n;* USAGE\r\n;*r19:r18:r17:r16 = ( r23:r22 * r21:r20 ) << 1\r\n ;******************************************************************************\r\nfmuls16x16_32: clr r2\r\nfmuls r23, r21 ;((signed)ah * (signed)bh) << 1\r\nmovw r19:r18, r1:r0\r\nfmul r22, r20 ;(al * bl) << 1\r\nadc r18, r2\r\nmovw r17:r16, r1:r0\r\nfmulsu r23, r20 ;((signed)ah * bl) << 1\r\nsbc r19, r2\r\nadd r17, r0\r\nadc r18, r1\r\nadc r19, r2\r\nfmulsu r21, r22 ;((signed)bh * al) << 1\r\nsbc r19, r2\r\nadd r17, r0\r\nadc r18, r1\r\nadc r19, r2"
  },
  {
    "command": "FMULS",
    "operands": "Rd, Rr",
    "operation": "R1:R0 \u2190 Rd x Rr",
    "description": "Multiply signed 1.7 fractional number by another. 16 \u2264 d \u2264 23, 16 \u2264 r \u2264 23",
    "flags": "------ZC",
    "cycles": "2",
    "opcode": "0000 0011 1ddd 0rrr",
    "example": "fmuls r23,r22 ; Multiply signed r23 and r22 in (1.7) format, result in (1.15) format\r\nmovw r23:r22,r1:r0 ; Copy result back in r23:r22"
  },
  {
    "command": "FMULSU",
    "operands": "Rd, Rr",
    "operation": "R1:R0 \u2190 Rd x Rr",
    "description": "Multiply 1.7 fractional signed number (Rd) by 1.7 fractional unsigned number (Rr). 16 \u2264 d \u2264 23, 16 \u2264 r \u2264 23",
    "flags": "------ZC",
    "cycles": "2",
    "opcode": "0000 0011 1ddd 1rrr",
    "example": ";******************************************************************************\r\n;* DESCRIPTION\r\n;*Signed fractional multiply of two 16-bit numbers with 32-bit result.\r\n;* USAGE\r\n;*r19:r18:r17:r16 = ( r23:r22 * r21:r20 ) << 1\r\n ;******************************************************************************\r\nfmuls16x16_32: clr r2\r\nfmuls r23, r21 ;((signed)ah * (signed)bh) << 1\r\nmovw r19:r18, r1:r0\r\nfmul r22, r20 ;(al * bl) << 1\r\nadc r18, r2\r\nmovw r17:r16, r1:r0\r\nfmulsu r23, r20 ;((signed)ah * bl) << 1\r\nsbc r19, r2\r\nadd r17, r0\r\nadc r18, r1\r\nadc r19, r2\r\nfmulsu r21, r22;((signed)bh * al) << 1\r\nsbc r19, r2\r\nadd r17, r0\r\nadc r18, r1\r\nadc r19, r2"
  },
  {
    "command": "ICALL",
    "operands": "",
    "operation": "PC\u2190Z; Stack\u2190PC + 1; SP\u2190SP\u20132",
    "description": "Indirect call to [Z] (High bits of Z discarded)",
    "flags": "--------",
    "cycles": "3",
    "opcode": "1001 0101 0000 1001",
    "example": "mov r30,r0 ; Set offset to call table\r\nicall ; Call routine pointed to by r31:r30"
  },
  {
    "command": "IJMP",
    "operands": "",
    "operation": "PC\u2190Z",
    "description": "Indirect Jump to [Z] (High bits of Z discarded)",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 0100 0000 1001",
    "example": "mov r30,r0 ; Set offset to jump table\r\nijmp ; Jump to routine pointed to by r31:r30"
  },
  {
    "command": "IN",
    "operands": "Rd, P",
    "operation": "Rd\u2190IO[P]",
    "description": "Load an I/O Location to Register",
    "flags": "--------",
    "cycles": "1",
    "opcode": "1011 0PPd dddd PPPP",
    "example": "in r25,$16 ; Read Port B\r\ncpi r25,4 ; Compare read value to constant\r\nbreqexit ; Branch if r25=4\r\n...\r\nexit: nop ; Branch destination (do nothing)"
  },
  {
    "command": "INC",
    "operands": "Rd",
    "operation": "Rd\u2190Rd + 1",
    "description": "Increment register",
    "flags": "---SVNZ-",
    "cycles": "1",
    "opcode": "1001 010d dddd 0011",
    "example": "clr r22 ; clear r22\r\nloop: inc r22 ; increment r22\r\n...\r\ncpi r22,$4F ; Compare r22 to $4f\r\nbrne loop ; Branch if not equal\r\nnop ; Continue (do nothing)"
  },
  {
    "command": "JMP",
    "operands": "k",
    "operation": "PC \u2190 k",
    "description": "Jump to address anywhere in program memory. (0 \u2264 k \u2264 4M)",
    "flags": "--------",
    "cycles": "3",
    "opcode": "1001 010k kkkk 110k kkkk kkkk kkkk kkkk",
    "example": "mov r1,r0 ; Copy r0 to r1\r\njmp farplc ; Unconditional jump\r\n...\r\nfarplc:nop ; Jump destination (do nothing)"
  },
  {
    "command": "LD",
    "operands": "Rd, W",
    "operation": "Rd\u2190M[W]",
    "description": "Load Indirect (Y or Z case)",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1000 000d dddd W000",
    "example": "clr r27 ; Clear X high byte\r\nldi r26,$60 ; Set X low byte to $60\r\nld r0,X+ ; Load r0 with data space loc. $60(X post inc)\r\nld r1,X ; Load r1 with data space loc. $61\r\nldi r26,$63 ; Set X low byte to $63\r\nld r2,X ; Load r2 with data space loc. $63\r\nld r3,-X ; Load r3 with data space loc. $62(X pre dec)"
  },
  {
    "command": "LD",
    "operands": "Rd, X",
    "operation": "Rd\u2190M[X]",
    "description": "Load Indirect (X case)",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 000d dddd 1100",
    "example": "clr r27 ; Clear X high byte\r\nldi r26,$60 ; Set X low byte to $60\r\nld r0,X+ ; Load r0 with data space loc. $60(X post inc)\r\nld r1,X ; Load r1 with data space loc. $61\r\nldi r26,$63 ; Set X low byte to $63\r\nld r2,X ; Load r2 with data space loc. $63\r\nld r3,-X ; Load r3 with data space loc. $62(X pre dec)"
  },
  {
    "command": "LDD",
    "operands": "Rd,W+\nq",
    "operation": "Rd\u2190M[W+q]",
    "description": "Load Indirect with Displacement (Y or Z only)",
    "flags": "--------",
    "cycles": "2",
    "opcode": "10q0 qq0d dddd Wqqq",
    "example": "clr r29 ; Clear Y high byte\r\nldi r28,$60 ; Set Y low byte to $60\r\nld r0,Y+ ; Load r0 with data space loc. $60(Y post inc)\r\nld r1,Y ; Load r1 with data space loc. $61\r\nldi r28,$63 ; Set Y low byte to $63\r\nld r2,Y ; Load r2 with data space loc. $63\r\nld r3,-Y ; Load r3 with data space loc. $62(Y pre dec)\r\nldd r4,Y+2 ; Load r4 with data space loc. $64"
  },
  {
    "command": "LD",
    "operands": "Rd,\n  W+",
    "operation": "Rd\u2190M[W]; W\u2190W+1",
    "description": "Load Indirect with Postincrement (Y or Z)",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 000d dddd W001",
    "example": "clr r27 ; Clear X high byte\r\nldi r26,$60 ; Set X low byte to $60\r\nld r0,X+ ; Load r0 with data space loc. $60(X post inc)\r\nld r1,X ; Load r1 with data space loc. $61\r\nldi r26,$63 ; Set X low byte to $63\r\nld r2,X ; Load r2 with data space loc. $63\r\nld r3,-X ; Load r3 with data space loc. $62(X pre dec)"
  },
  {
    "command": "LD",
    "operands": "Rd,\n  X+",
    "operation": "Rd\u2190M[X]; X\u2190X+1",
    "description": "Load Indirect with Postincrement (X)",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 000d dddd 1101",
    "example": "clr r27 ; Clear X high byte\r\nldi r26,$60 ; Set X low byte to $60\r\nld r0,X+ ; Load r0 with data space loc. $60(X post inc)\r\nld r1,X ; Load r1 with data space loc. $61\r\nldi r26,$63 ; Set X low byte to $63\r\nld r2,X ; Load r2 with data space loc. $63\r\nld r3,-X ; Load r3 with data space loc. $62(X pre dec)"
  },
  {
    "command": "LD",
    "operands": "Rd,\n  -W",
    "operation": "W\u2190W-1; Rd\u2190M[W]",
    "description": "Load Indirect with Pre-decrement (Y or Z)",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 000d dddd W010",
    "example": "clr r27 ; Clear X high byte\r\nldi r26,$60 ; Set X low byte to $60\r\nld r0,X+ ; Load r0 with data space loc. $60(X post inc)\r\nld r1,X ; Load r1 with data space loc. $61\r\nldi r26,$63 ; Set X low byte to $63\r\nld r2,X ; Load r2 with data space loc. $63\r\nld r3,-X ; Load r3 with data space loc. $62(X pre dec)"
  },
  {
    "command": "LD",
    "operands": "Rd, -X",
    "operation": "X\u2190X-1; Rd\u2190M[X]",
    "description": "Load Indirect with Pre-decrement (X)",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 000d dddd 1110",
    "example": "clr r27 ; Clear X high byte\r\nldi r26,$60 ; Set X low byte to $60\r\nld r0,X+ ; Load r0 with data space loc. $60(X post inc)\r\nld r1,X ; Load r1 with data space loc. $61\r\nldi r26,$63 ; Set X low byte to $63\r\nld r2,X ; Load r2 with data space loc. $63\r\nld r3,-X ; Load r3 with data space loc. $62(X pre dec)"
  },
  {
    "command": "LDI",
    "operands": "Rd,\n  K",
    "operation": "Rd\u2190K",
    "description": "Load Immediate, 16 \u2264 d \u2264 31",
    "flags": "--------",
    "cycles": "1",
    "opcode": "1110 KKKK dddd KKKK",
    "example": "clrr31 ; Clear Z high byte\r\nldi r30, $F0 ; Set Z low byte to $F0\r\nlpm ; Load constant from program\r\n; memory pointed to by Z"
  },
  {
    "command": "LDS",
    "operands": "Rd,\n  k",
    "operation": "Rd\u2190M[k]",
    "description": "Load Direct from SRAM, 0\u2264k\u226465535",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 000d dddd 0000 kkkk kkkk kkkk kkkk",
    "example": "lds r2,$FF00 ; Load r2 with the contents of data space location $FF00\r\nadd r2,r1 ; add r1 to r2\r\nsts $FF00,r2 ; Write back"
  },
  {
    "command": "LPM",
    "operands": "",
    "operation": "R0\u2190PM[Z]",
    "description": "Load program memory, Z contains a byte address. Least significant bit of Z selects low byte of the program word (if 0) or high byte (if 1)",
    "flags": "--------",
    "cycles": "3",
    "opcode": "1001 0101 1100 1000",
    "example": "ldi ZH, high(Table_1<<1) ; Initialize Z pointer\r\nldi ZL, low(Table_1<<1)\r\nlpm r16, Z ; Load constant from program\r\n; memory pointed to by Z (r31:r30)\r\n...\r\nTable_1:\r\n.dw 0x5876; 0x76 is addresses when ZLSB = 0\r\n; 0x58 is addresses when ZLSB = 1\r\n..."
  },
  {
    "command": "LPM",
    "operands": "Rd,\n  Z",
    "operation": "Rd\u2190PM[Z]",
    "description": "As above, destination is Rd",
    "flags": "--------",
    "cycles": "3",
    "opcode": "1001 000d dddd 0100",
    "example": "ldi ZH, high(Table_1<<1) ; Initialize Z pointer\r\nldi ZL, low(Table_1<<1)\r\nlpm r16, Z ; Load constant from program\r\n; memory pointed to by Z (r31:r30)\r\n...\r\nTable_1:\r\n.dw 0x5876; 0x76 is addresses when ZLSB = 0\r\n; 0x58 is addresses when ZLSB = 1\r\n..."
  },
  {
    "command": "LPM",
    "operands": "Rd, Z+",
    "operation": "R0\u2190PM[Z] Z\u2190Z+1",
    "description": "As above, destination is Rd. Z is incremented",
    "flags": "--------",
    "cycles": "3",
    "opcode": "1001 000d dddd 0100",
    "example": "ldi ZH, high(Table_1<<1) ; Initialize Z pointer\r\nldi ZL, low(Table_1<<1)\r\nlpm r16, Z ; Load constant from program\r\n; memory pointed to by Z (r31:r30)\r\n...\r\nTable_1:\r\n.dw 0x5876; 0x76 is addresses when ZLSB = 0\r\n; 0x58 is addresses when ZLSB = 1\r\n..."
  },
  {
    "command": "LSL",
    "operands": "Rd",
    "operation": "C\u2190Rd(7); Rd(7\u20261) \u2190Rd(6\u20260); Rd(0) \u21900",
    "description": "Logical Shift Left, Same as add Rd,Rd",
    "flags": "--HSVNZC",
    "cycles": "1",
    "opcode": "0000 11Dd dddd DDDD (DDDDD=ddddd)",
    "example": "add r0, r4 ; Add r4 to r0\r\nlsl r0 ; Multiply r0 by 2"
  },
  {
    "command": "LSR",
    "operands": "Rd",
    "operation": "C\u2190Rd(0); Rd(6\u20260) \u2190Rd(7\u20261); Rd(7) \u21900",
    "description": "Logical Shift Right",
    "flags": "---SVNZC, \nN\u21900",
    "cycles": "1",
    "opcode": "1001 010d dddd 0110",
    "example": "add r0,r4 ; Add r4 to r0\r\nlsr r0 ; Divide r0 by 2"
  },
  {
    "command": "MOV",
    "operands": "Rd,\n  Rr",
    "operation": "Rd\u2190Rr",
    "description": "Move between registers",
    "flags": "--------",
    "cycles": "1",
    "opcode": "0010 11rd dddd rrrr",
    "example": "mov r16,r0 ; Copy r0 to r16\r\ncall check ; Call subroutine\r\n...\r\ncheck: cpi r16,$11 ; Compare r16 to $11\r\n...\r\nret ; Return from subroutine"
  },
  {
    "command": "MOVW",
    "operands": "Rd,\n  Rr",
    "operation": "Rd+1:Rd\u2190 Rr+1:Rr",
    "description": "Copy one register pair to another. d=0,2,4\u202630; r=0,2,4\u202630",
    "flags": "--------",
    "cycles": "1",
    "opcode": "0000 0001 dddd rrrr",
    "example": "movw r17:16,r1:r0 ; Copy r1:r0 to r17:r16\r\ncall check ; Call subroutine\r\n...\r\ncheck: cpi r16,$11 ; Compare r16 to $11\r\n...\r\ncpi r17,$32 ; Compare r17 to $32\r\n...\r\nret ; Return from subroutine"
  },
  {
    "command": "MUL",
    "operands": "Rd,\n  Rr",
    "operation": "R1:R0 \u2190 Rd x Rr",
    "description": "Multiply two 8-bit unsigned numbers. (Unsigned result)",
    "flags": "------ZC",
    "cycles": "2",
    "opcode": "1001 11rd dddd rrrr",
    "example": "mul r5,r4 ; Multiply unsigned r5 and r4\r\nmovw r4,r0 ; Copy result back in r5:r4"
  },
  {
    "command": "MULS",
    "operands": "Rd,\n  Rr",
    "operation": "R1:R0 \u2190 Rd x Rr",
    "description": "Multiply two 8-bit signed numbers. 16 \u2264 d \u2264 31, 16 \u2264 r \u2264 31",
    "flags": "------ZC",
    "cycles": "2",
    "opcode": "0000 0010 dddd rrrr",
    "example": "muls r21,r20 ; Multiply signed r21 and r20\r\nmovw r20,r0 ; Copy result back in r21:r20"
  },
  {
    "command": "MULSU",
    "operands": "Rd,\n  Rr",
    "operation": "R1:R0 \u2190 Rd x Rr",
    "description": "Multiply 8-bit signed number (Rd) by 8-bit unsigned number (Rr). 16 \u2264 d \u2264 23, 16 \u2264 r \u2264 23",
    "flags": "------ZC",
    "cycles": "2",
    "opcode": "0000 0011 0ddd 0rrr",
    "example": ";******************************************************************************\r\n ;* DESCRIPTION\r\n ;*Signed multiply of two 16-bit numbers with 32-bit result.\r\n ;* USAGE\r\n ;*r19:r18:r17:r16 = r23:r22 * r21:r20\r\n ;******************************************************************************\r\n muls16x16_32:\r\nclr r2\r\nmuls r23, r21 ; (signed)ah * (signed)bh\r\nmovw r19:r18, r1:r0\r\nmul r22, r20; al * bl\r\nmovw r17:r16, r1:r0\r\nmulsu r23, r20 ; (signed)ah * bl\r\nsbc r19, r2\r\nadd r17, r0\r\nadc r18, r1\r\nadc r19, r2\r\nmulsu r21, r22 ; (signed)bh * al\r\nsbc r19, r2\r\nadd r17, r0\r\nadc r18, r1\r\nadc r19, r2\r\nret"
  },
  {
    "command": "NEG",
    "operands": "Rd",
    "operation": "Rd\u2190$00 \u2013 Rd",
    "description": "Two\u2019s complement (negation)",
    "flags": "--HSVNZC",
    "cycles": "1",
    "opcode": "1001 010d dddd 0001",
    "example": "sub r11,r0 ; Subtract r0 from r11\r\nbrpl positive ; Branch if result positive\r\nneg r11 ; Take two's complement of r11\r\npositive: nop ; Branch destination (do nothing)"
  },
  {
    "command": "NOP",
    "operands": "",
    "operation": "",
    "description": "No operation",
    "flags": "--------",
    "cycles": "1",
    "opcode": "0000 0000 0000 0000",
    "example": "clr r16 ; Clear r16\r\nser r17 ; Set r17\r\nout$18,r16 ; Write zeros to Port B\r\nnop ; Wait (do nothing)\r\nout$18,r17 ; Write ones to Port B"
  },
  {
    "command": "OR",
    "operands": "Rd,Rr",
    "operation": "Rd\u2190Rd or Rr",
    "description": "Logical OR two registers",
    "flags": "---SVNZ-, \nV\n  cleared",
    "cycles": "1",
    "opcode": "0010 10rd dddd rrrr",
    "example": "or r15,r16 ; Do bitwise or between registers\r\nbst r15,6 ; Store bit 6 of r15 in T flag\r\nbrts ok ; Branch if T flag set\r\n...\r\nok: nop ; Branch destination (do nothing)"
  },
  {
    "command": "ORI",
    "operands": "Rd,\n  K",
    "operation": "Rd\u2190Rd or K",
    "description": "Logical OR with immediate, 16 \u2264 d \u2264 31",
    "flags": "---SVNZ-, \nV\n  cleared",
    "cycles": "1",
    "opcode": "0110 KKKK dddd KKKK",
    "example": "ori r16,$F0 ; Set high nibble of r16\r\nori r17,1 ; Set bit 0 of r17"
  },
  {
    "command": "OUT",
    "operands": "P,\n  Rr",
    "operation": "IO[P] \u2190Rr",
    "description": "Store Register to I/O Location",
    "flags": "--------",
    "cycles": "1",
    "opcode": "1011 1PPr rrrr PPPP",
    "example": "clr r16 ; Clear r16\r\nser r17 ; Set r17\r\nout $18,r16 ; Write zeros to Port B\r\nnop ; Wait (do nothing)\r\nout $18,r17 ; Write ones to Port B"
  },
  {
    "command": "POP",
    "operands": "Rd",
    "operation": "SP\u2190SP+1; Rd\u2190STACK",
    "description": "Pop register from stack",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 000d dddd 1111",
    "example": "callroutine ; Call subroutine\r\n ...\r\n routine: pushr14 ; Save r14 on the stack\r\npush r13 ; Save r13 on the stack\r\n...\r\npop r13 ; Restore r13\r\npop r14 ; Restore r14\r\nret ; Return from subroutine"
  },
  {
    "command": "PUSH",
    "operands": "Rr",
    "operation": "STACK\u2190Rr; SP\u2190SP\u20131",
    "description": "Push register on Stack",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 001r rrrr 1111",
    "example": "call routine ; Call subroutine\r\n...\r\nroutine: push r14 ; Save r14 on the stack\r\npush r13 ; Save r13 on the stack\r\n...\r\npop r13 ; Restore r13\r\npop r14 ; Restore r14\r\nret ; Return from subroutine"
  },
  {
    "command": "RCALL",
    "operands": "k",
    "operation": "PC\u2190PC + k + 1; Stack\u2190PC + 1; SP\u2190SP\u20132",
    "description": "Relative Subroutine Call, -2048 \u2264 k \u2264 2047",
    "flags": "--------",
    "cycles": "3",
    "opcode": "1101 kkkk kkkk kkkk",
    "example": "rcall routine ; Call subroutine\r\n...\r\n routine: push r14 ; Save r14 on the stack\r\n...\r\npop r14 ; Restore r14\r\nret ; Return from subroutine"
  },
  {
    "command": "RET",
    "operands": "",
    "operation": "SP\u2190SP+2; PC\u2190Stack",
    "description": "Subroutine return",
    "flags": "--------",
    "cycles": "4",
    "opcode": "1001 0101 0000 1000",
    "example": "callroutine ; Call subroutine\r\n...\r\n routine: push r14 ; Save r14 on the stack\r\n...\r\npop r14 ; Restore r14\r\nret ; Return from subroutine"
  },
  {
    "command": "RETI",
    "operands": "",
    "operation": "SP\u2190SP+2; PC\u2190Stack",
    "description": "Return from interrupt (and enable interrupts)",
    "flags": "I-------, \nI\n  is set",
    "cycles": "4",
    "opcode": "1001 0101 0001 1000",
    "example": "...\r\n extint: push r0 ; Save r0 on the stack\r\n...\r\npop r0 ; Restore r0\r\nreti ; Return and enable interrupts"
  },
  {
    "command": "RJMP",
    "operands": "k",
    "operation": "PC\u2190PC + k + 1;",
    "description": "Relative Jump, -2048 <= k <= 2047",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1100 kkkk kkkk kkkk",
    "example": "cpi r16,$42 ; Compare r16 to $42\r\nbrne error ; Branch if r16 \u21d4 $42\r\nrjmpok ; Unconditional branch\r\nerror: addr16,r17 ; Add r17 to r16\r\nincr16 ; Increment r16\r\nok: nop ; Destination for rjmp (do nothing)"
  },
  {
    "command": "ROL",
    "operands": "Rd",
    "operation": "C\u2190Rd(7); Rd(7\u20261) \u2190Rd(6\u20260); Rd(0) \u2190C",
    "description": "Rotate left through carry, Same as adc Rd,Rd",
    "flags": "--HSVNZC",
    "cycles": "1",
    "opcode": "0001 11Dd dddd DDDD (DDDDD=ddddd)",
    "example": "lsl r18 ; Multiply r19:r18 by two\r\nrol r19 ; r19:r18 is a signed or unsigned two-byte integer\r\n brcsoneenc ; Branch if carry set\r\n...\r\noneenc:nop ; Branch destination (do nothing)"
  },
  {
    "command": "ROR",
    "operands": "Rd",
    "operation": "C\u2190Rd(0); Rd(6\u20260) \u2190Rd(7\u20261); Rd(7) \u2190C",
    "description": "Rotate right through carry",
    "flags": "---SVNZC",
    "cycles": "1",
    "opcode": "1001 010d dddd 0111",
    "example": "lsr r19 ; Divide r19:r18 by two\r\nror r18 ; r19:r18 is an unsigned two-byte integer\r\nbrcc zeroenc1 ; Branch if carry cleared\r\nasr r17 ; Divide r17:r16 by two\r\nror r16 ; r17:r16 is a signed two-byte integer\r\nbrcc zeroenc2 ; Branch if carry cleared\r\n...\r\nzeroenc1:nop ; Branch destination (do nothing)\r\n...\r\nzeroenc2:nop ; Branch destination (do nothing)"
  },
  {
    "command": "SBC",
    "operands": "Rd,\n  Rr",
    "operation": "Rd\u2190Rd \u2013 Rr \u2013 C",
    "description": "Subtract two registers with carry",
    "flags": "--HSVNZC",
    "cycles": "1",
    "opcode": "0000 10rd dddd rrrr",
    "example": "; Subtract r1:r0 from r3:r2\r\nsub r2,r0 ; Subtract low byte\r\nsbc r3,r1 ; Subtract with carry high byte"
  },
  {
    "command": "SBCI",
    "operands": "Rd,\n  K",
    "operation": "Rd\u2190Rd \u2013 K \u2013 C",
    "description": "Subtract immediate with carry, 16 \u2264 d \u2264 31",
    "flags": "--HSVNZC",
    "cycles": "1",
    "opcode": "0100 KKKK dddd KKKK",
    "example": "; Subtract $4F23 from r17:r16\r\nsubi r16,$23 ; Subtract low byte\r\nsbci r17,$4F ; Subtract with carry high byte"
  },
  {
    "command": "SBI",
    "operands": "P,\n  b",
    "operation": "IO[P](b) \u21901",
    "description": "Set bit in I/O register, 0<=P<=31",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 1010 PPPP Pbbb",
    "example": "out $1E,r0 ; Write EEPROM address\r\nsbi $1C,0 ; Set read bit in EECR\r\nin r1,$1D ; Read EEPROM data"
  },
  {
    "command": "SBIC",
    "operands": "P, b",
    "operation": "if(IO[P](b) = 0) PC\u2190PC + 2 (or 3)",
    "description": "Skip if bit in I/O register is cleared, 0<=P<=31",
    "flags": "--------",
    "cycles": "1,2,\n3\u2020",
    "opcode": "1001 1001 PPPP Pbbb",
    "example": "e2wait: sbic $1C,1 ; Skip next inst. if EEWE cleared\r\nrjmp e2wait ; EEPROM write not finished\r\nnop; Continue (do nothing)"
  },
  {
    "command": "SBIS",
    "operands": "P, b",
    "operation": "if(IO[P](b) = 1) PC\u2190PC + 2 (or 3)",
    "description": "Skip if bit in I/O register is set, 0<=P<=31",
    "flags": "--------",
    "cycles": "1,2,\n3\u2020",
    "opcode": "1001 1011 PPPP Pbbb",
    "example": "waitset: sbis $10,0 ; Skip next inst. if bit 0 in Port D set\r\nrjmp waitset ; Bit not set\r\nnop ; Continue (do nothing)"
  },
  {
    "command": "SBIW",
    "operands": "Rh:Rl, K",
    "operation": "Rh:Rl\u2190Rh:Rl\u2013K",
    "description": "Subtract immediate from word, 0 \u2264 K \u2264 63",
    "flags": "---SVNZC",
    "cycles": "2",
    "opcode": "1001 0111 KKdd KKKK",
    "example": "sbiw r25:r24,1 ; Subtract 1 from r25:r24\r\nsbiw YH:YL,63 ; Subtract 63 from the Y pointer(r29:r28)"
  },
  {
    "command": "SBR",
    "operands": "Rd, K",
    "operation": "Rd\u2190Rd or K",
    "description": "Set bit(s) in register, 16 \u2264 d \u2264 31, same as ori",
    "flags": "---SVNZ-,\n  \nV cleared",
    "cycles": "1",
    "opcode": "0110 KKKK dddd KKKK",
    "example": "sbr r16,3 ; Set bits 0 and 1 in r16\r\nsbr r17,$F0 ; Set 4 MSB in r17"
  },
  {
    "command": "SBRC",
    "operands": "Rr, b",
    "operation": "if(Rr(b) = 0) PC\u2190PC + 2 (or 3)",
    "description": "Skip if bit in register is cleared",
    "flags": "--------",
    "cycles": "1,2,\n3\u2020",
    "opcode": "1111 110r rrrr 0bbb",
    "example": "sub r0,r1 ; Subtract r1 from r0\r\nsbrc r0,7 ; Skip if bit 7 in r0 cleared\r\nsub r0,r1 ; Only executed if bit 7 in r0 not cleared\r\nnop ; Continue (do nothing)"
  },
  {
    "command": "SBRS",
    "operands": "Rr, b",
    "operation": "if(Rr(b) = 1) PC\u2190PC + 2 (or 3)",
    "description": "Skip if bit in register is set",
    "flags": "--------",
    "cycles": "1,2,\n3\u2020",
    "opcode": "1111 111r rrrr 0bbb",
    "example": "sub r0,r1 ; Subtract r1 from r0\r\nsbrs r0,7 ; Skip if bit 7 in r0 set\r\nneg r0 ; Only executed if bit 7 in r0 not set\r\nnop ; Continue (do nothing)"
  },
  {
    "command": "SEC",
    "operands": "",
    "operation": "C\u21901",
    "description": "Set carry flag, Same as bset 0",
    "flags": "-------C",
    "cycles": "1",
    "opcode": "1001 0100 0000 1000",
    "example": "sec ; Set carry flag\r\nadc r0,r1 ; r0=r0+r1+1"
  },
  {
    "command": "SEH",
    "operands": "",
    "operation": "H\u21901",
    "description": "Set half-carry flag, Same as bset 5",
    "flags": "--H-----",
    "cycles": "1",
    "opcode": "1001 0100 0101 1000",
    "example": "seh ; Set Half Carry flag"
  },
  {
    "command": "SEI",
    "operands": "",
    "operation": "I\u21901",
    "description": "Set global interrupt flag (enable interrupts). Instruction following sei will always be executed before any pending interrupts are handled. Same as bset 7",
    "flags": "I-------",
    "cycles": "1",
    "opcode": "1001 0100 0111 1000",
    "example": "sei ; set global interrupt enable\r\nsleep ; enter sleep, waiting for interrupt\r\n; note: will enter sleep before any pending interrupt(s)"
  },
  {
    "command": "SEN",
    "operands": "",
    "operation": "N\u21901",
    "description": "Set negative flag, Same as bset 2",
    "flags": "-----N--",
    "cycles": "1",
    "opcode": "1001 0100 0010 1000",
    "example": "add r2,r19 ; Add r19 to r2\r\nsen ; Set negative flag"
  },
  {
    "command": "SER",
    "operands": "Rd",
    "operation": "Rd\u2190$FF",
    "description": "Set register, 16 \u2264 d \u2264 31, Same as LDI Rd, $FF",
    "flags": "--------",
    "cycles": "1",
    "opcode": "1110 1111 dddd 1111",
    "example": "clr r16 ; Clear r16\r\nser r17 ; Set r17\r\nout $18,r16 ; Write zeros to Port B\r\nnop ; Delay (do nothing)\r\nout $18,r17 ; Write ones to Port B"
  },
  {
    "command": "SES",
    "operands": "",
    "operation": "S\u21901",
    "description": "Set signed flag, Same as bset 4",
    "flags": "---S----",
    "cycles": "1",
    "opcode": "1001 0100 0100 1000",
    "example": "add r2,r19 ; Add r19 to r2\r\nses ; Set negative flag"
  },
  {
    "command": "SET",
    "operands": "",
    "operation": "T\u21901",
    "description": "Set T flag, Same as bset 6",
    "flags": "-T------",
    "cycles": "1",
    "opcode": "1001 0100 0110 1000",
    "example": "set ; Set T flag"
  },
  {
    "command": "SEV",
    "operands": "",
    "operation": "V\u21901",
    "description": "Set overflow flag, Same as bset 3",
    "flags": "----V---",
    "cycles": "1",
    "opcode": "1001 0100 0011 1000",
    "example": "add r2,r19; Add r19 to r2\r\nsev ; Set overflow flag"
  },
  {
    "command": "SEZ",
    "operands": "",
    "operation": "Z\u21901",
    "description": "Set zero flag, Same as bset 1",
    "flags": "------Z-",
    "cycles": "1",
    "opcode": "1001 0100 0001 1000",
    "example": "add r2,r19 ; Add r19 to r2\r\nsez ; Set zero flag"
  },
  {
    "command": "SLEEP",
    "operands": "",
    "operation": "",
    "description": "Sleep. Sets CPU in sleep mode defined by the MCU control register",
    "flags": "--------",
    "cycles": "1",
    "opcode": "1001 0101 1000 1000",
    "example": "mov r0,r11 ; Copy r11 to r0\r\nldi r16,(1<<SE) ; Enable sleep mode\r\nout MCUCR, r16\r\nsleep ; Put MCU in sleep mode"
  },
  {
    "command": "SPM",
    "operands": "",
    "operation": "PM[Z] \u2190R1:R0",
    "description": "Store program memory \u2013 see instruction reference manual for details.",
    "flags": "--------",
    "cycles": "Varies",
    "opcode": "1001 0101 1110 1000",
    "example": ";This example shows SPM write of one page for devices with page write\r\n ;- the routine writes one page of data from RAM to Flash\r\n ; the first data location in RAM is pointed to by the Y pointer\r\n ; the first data location in Flash is pointed to by the Z pointer\r\n ;- error handling is not included\r\n ;- the routine must be placed inside the boot space\r\n ; (at least the do_spm sub routine)\r\n ;- registers used: r0, r1, temp1, temp2, looplo, loophi, spmcrval\r\n ; (temp1, temp2, looplo, loophi, spmcrval must be defined by the user)\r\n ; storing and restoring of registers is not included in the routine\r\n ; register usage can be optimized at the expense of code size\r\n .equ PAGESIZEB = PAGESIZE*2;PAGESIZEB is page size in BYTES, not words\r\n .org SMALLBOOTSTART\r\n write_page:\r\n;page erase\r\nldi spmcrval, (1<<PGERS) + (1<<SPMEN)\r\ncall do_spm\r\n ;transfer data from RAM to Flash page buffer\r\nldi looplo, low(PAGESIZEB) ;init loop variable\r\nldi loophi, high(PAGESIZEB) ;not required for PAGESIZEB<=256\r\n wrloop:ld r0, Y+\r\nld r1, Y+\r\nldi spmcrval, (1<<SPMEN)\r\ncall do_spm\r\nadiw ZH:ZL, 2\r\nsbiw loophi:looplo, 2;use subi for PAGESIZEB<=256\r\nbrne wrloop\r\n ;execute page write\r\nsubi ZL, low(PAGESIZEB) ;restore pointer\r\nsbci ZH, high(PAGESIZEB) ;not required for PAGESIZEB<=256\r\nldi spmcrval, (1<<PGWRT) + (1<<SPMEN)\r\ncall do_spm\r\n;read back and check, optional\r\nldi looplo, low(PAGESIZEB) ;init loop variable\r\nldi loophi, high(PAGESIZEB) ;not required for PAGESIZEB<=256\r\nsubi YL, low(PAGESIZEB) ;restore pointer\r\nsbci YH, high(PAGESIZEB)\r\n rdloop:lpmr0, Z+\r\nldr 1, Y+\r\ncp ser0, r1\r\njmp error\r\nsbi wloophi:looplo, 2;use subi for PAGESIZEB<=256\r\nbrne rdloop\r\n ;return\r\nret\r\n do_spm:\r\n ;input: spmcrval determines SPM action\r\n ;disable interrupts if enabled, store status\r\nin temp2, SREG\r\ncli\r\n;check for previous SPM complete\r\n wait:intemp1, SPMCR\r\nsbr ctemp1, SPMEN\r\nrjm pwait\r\n;SPM timed sequence\r\nout SPMCR, spmcrval\r\nspm\r\n ;restore SREG (to enable interrupts if originally enabled)\r\nout SREG, temp2\r\nret"
  },
  {
    "command": "ST",
    "operands": "W, Rr",
    "operation": "M[W] \u2190Rr",
    "description": "Store Indirect (Y or Z cases)",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1000 001r rrrr W000",
    "example": "clr r27 ; Clear X high byte\r\nldi r26,$60 ; Set X low byte to $60\r\nst X+,r0 ; Store r0 in data space loc. $60(X post inc)\r\nst X,r1 ; Store r1 in data space loc. $61\r\nldi r26,$63 ; Set X low byte to $63\r\nst X,r2 ; Store r2 in data space loc. $63\r\nst -X,r3 ; Store r3 in data space loc. $62(X pre dec)"
  },
  {
    "command": "ST",
    "operands": "X, Rr",
    "operation": "M[X] \u2190Rr",
    "description": "Store Indirect (X case)",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 001r rrrr 1100",
    "example": "clr r27 ; Clear X high byte\r\nldi r26,$60 ; Set X low byte to $60\r\nst X+,r0 ; Store r0 in data space loc. $60(X post inc)\r\nst X,r1 ; Store r1 in data space loc. $61\r\nldi r26,$63 ; Set X low byte to $63\r\nst X,r2 ; Store r2 in data space loc. $63\r\nst -X,r3 ; Store r3 in data space loc. $62(X pre dec)"
  },
  {
    "command": "ST",
    "operands": "W+,\n  Rr",
    "operation": "M[W] \u2190Rr; W\u2190W+1",
    "description": "Store Indirect with Postincrement (Y or Z)",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 001r rrrr W001",
    "example": "clr r27 ; Clear X high byte\r\nldi r26,$60 ; Set X low byte to $60\r\nst X+,r0 ; Store r0 in data space loc. $60(X post inc)\r\nst X,r1 ; Store r1 in data space loc. $61\r\nldi r26,$63 ; Set X low byte to $63\r\nst X,r2 ; Store r2 in data space loc. $63\r\nst -X,r3 ; Store r3 in data space loc. $62(X pre dec)"
  },
  {
    "command": "ST",
    "operands": "X+,\n  Rr",
    "operation": "M[X] \u2190Rr; X\u2190X+1",
    "description": "Store Indirect with Postincrement (X)",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 001r rrrr 1101",
    "example": "clr r27 ; Clear X high byte\r\nldi r26,$60 ; Set X low byte to $60\r\nst X+,r0 ; Store r0 in data space loc. $60(X post inc)\r\nst X,r1 ; Store r1 in data space loc. $61\r\nldi r26,$63 ; Set X low byte to $63\r\nst X,r2 ; Store r2 in data space loc. $63\r\nst -X,r3 ; Store r3 in data space loc. $62(X pre dec)"
  },
  {
    "command": "ST",
    "operands": "-W,\n  Rr",
    "operation": "W\u2190W-1; M[W] \u2190Rr",
    "description": "Store Indirect with Pre-decrement (Y or Z)",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 001r rrrr W010",
    "example": "clr r27 ; Clear X high byte\r\nldi r26,$60 ; Set X low byte to $60\r\nst X+,r0 ; Store r0 in data space loc. $60(X post inc)\r\nst X,r1 ; Store r1 in data space loc. $61\r\nldi r26,$63 ; Set X low byte to $63\r\nst X,r2 ; Store r2 in data space loc. $63\r\nst -X,r3 ; Store r3 in data space loc. $62(X pre dec)"
  },
  {
    "command": "ST",
    "operands": "-X, Rr",
    "operation": "X\u2190X-1; M[X] \u2190Rr",
    "description": "Store Indirect with Pre-decrement (X)",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 001r rrrr 1110",
    "example": "clr r27 ; Clear X high byte\r\nldi r26,$60 ; Set X low byte to $60\r\nst X+,r0 ; Store r0 in data space loc. $60(X post inc)\r\nst X,r1 ; Store r1 in data space loc. $61\r\nldi r26,$63 ; Set X low byte to $63\r\nst X,r2 ; Store r2 in data space loc. $63\r\nst -X,r3 ; Store r3 in data space loc. $62(X pre dec)"
  },
  {
    "command": "STD",
    "operands": "W+q,Rr",
    "operation": "M[W+q] \u2190Rr",
    "description": "Store Indirect with Displacement (Y or Z only)",
    "flags": "--------",
    "cycles": "2",
    "opcode": "10q0 qq1r rrrr Wqqq",
    "example": "clr r29 ; Clear Y high byte\r\nldi r28,$60 ; Set Y low byte to $60\r\nst Y+,r0 ; Store r0 in data space loc. $60(Y post inc)\r\nst Y,r1 ; Store r1 in data space loc. $61\r\nldi r28,$63 ; Set Y low byte to $63\r\nst Y,r2 ; Store r2 in data space loc. $63\r\nst -Y,r3 ; Store r3 in data space loc. $62(Y pre dec)\r\nstd Y+2,r4 ; Store r4 in data space loc. $64"
  },
  {
    "command": "STS",
    "operands": "k, Rr",
    "operation": "M[k] \u2190Rr",
    "description": "Store Direct To SRAM",
    "flags": "--------",
    "cycles": "2",
    "opcode": "1001 001r rrrr 0000 kkkk kkkk kkkk kkkk",
    "example": "lds r2,$FF00 ; Load r2 with the contents of data space location $FF00\r\nadd r2,r1 ; add r1 to r2\r\nsts $FF00,r2 ; Write back"
  },
  {
    "command": "SUB",
    "operands": "Rd, Rr",
    "operation": "Rd\u2190Rd - Rr",
    "description": "Subtract two registers",
    "flags": "--HSVNZC",
    "cycles": "1",
    "opcode": "0001 10rd dddd rrrr",
    "example": "sub r13,r12 ; Subtract r12 from r13\r\nbrne noteq ; Branch if r12\u21d4r13\r\n...\r\nnoteq: nop ; Branch destination (do nothing)"
  },
  {
    "command": "SUBI",
    "operands": "Rd, K",
    "operation": "Rd\u2190Rd \u2013 K",
    "description": "Subtract immediate, 16 \u2264 d \u2264 31",
    "flags": "--HSVNZC",
    "cycles": "1",
    "opcode": "0101 KKKK dddd KKKK",
    "example": "subi r22,$11 ; Subtract $11 from r22\r\nbrne noteq ; Branch if r22\u21d4$11\r\n ...\r\n noteq: nop ; Branch destination (do nothing)"
  },
  {
    "command": "SWAP",
    "operands": "Rd",
    "operation": "Rd(7\u20264) \u2190Rd(3\u20260); Rd(3\u20260) \u2190Rd(7\u20264)",
    "description": "Swap nibbles (i.e. high 4 bits is exchanged with low 4 bits)",
    "flags": "--------",
    "cycles": "1",
    "opcode": "1001 010d dddd 0010",
    "example": "inc r1 ; Increment r1\r\nswap r1 ; Swap high and low nibble of r1\r\ninc r1 ; Increment high nibble of r1\r\nswap r1 ; Swap back"
  },
  {
    "command": "TST",
    "operands": "Rd",
    "operation": "Rd\u2190Rd \u2022 Rd",
    "description": "Test for zero or minus, same as And Rd, Rd",
    "flags": "---SVNZ-,\n  \nV cleared",
    "cycles": "1",
    "opcode": "0010 00Dd dddd DDDD (DDDDD=ddddd)",
    "example": "tst r0 ; Test r0\r\nbreq zero ; Branch if r0=0\r\n...\r\nzero: nop ; Branch destination (do nothing)"
  },
  {
    "command": "WDR",
    "operands": "",
    "operation": "",
    "description": "Watchdog reset",
    "flags": "--------",
    "cycles": "1",
    "opcode": "1001 0101 1010 1000",
    "example": "wdr ; Reset watchdog timer"
  }
]